<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>えいご じしょ</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
            background: #f0f8ff;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            max-width: 100%;
        }

        .camera-container {
            position: relative;
            flex: 1;
            background: #000;
            overflow: hidden;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas, #detectCanvas {
            display: none;
        }

        .focus-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            transition: all 0.15s ease-out;
        }

        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border-color: #4caf50;
            border-style: solid;
            border-width: 0;
        }

        .corner-tl { top: 0; left: 0; border-top-width: 5px; border-left-width: 5px; }
        .corner-tr { top: 0; right: 0; border-top-width: 5px; border-right-width: 5px; }
        .corner-bl { bottom: 0; left: 0; border-bottom-width: 5px; border-left-width: 5px; }
        .corner-br { bottom: 0; right: 0; border-bottom-width: 5px; border-right-width: 5px; }

        .focus-overlay.tracking .corner { border-color: #4caf50; }
        .focus-overlay.not-tracking .corner { border-color: #ffeb3b; }

        .card-mask {
            position: absolute;
            pointer-events: none;
            z-index: 9;
            background: rgba(76, 175, 80, 0.15);
            transition: all 0.15s ease-out;
            border-radius: 8px;
        }

        .card-mask.not-tracking {
            background: rgba(255, 235, 59, 0.1);
        }

        /* Settings button */
        .settings-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 15;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Settings modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            padding: 25px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
        }

        .modal h2 {
            margin-bottom: 15px;
            font-size: 18px;
        }

        .modal label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #666;
        }

        .modal input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
        }

        .modal-buttons .save-btn {
            background: #4caf50;
            color: white;
        }

        .modal-buttons .cancel-btn {
            background: #ddd;
        }

        .api-status {
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .api-status.active {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .api-status.inactive {
            background: #fff3e0;
            color: #ef6c00;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 15px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom, 0));
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            flex-shrink: 0;
        }

        .button-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .btn {
            flex: 1;
            max-width: 180px;
            padding: 15px 12px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn:active { transform: scale(0.95); }
        .btn-capture {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }
        .btn-speak {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }
        .btn-translate {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(67, 233, 123, 0.4);
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .result-area {
            background: white;
            border-radius: 12px;
            padding: 10px 12px;
            margin-bottom: 4px;
            min-height: 60px;
            max-height: 120px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .english-text { font-size: 24px; font-weight: bold; color: #333; margin-bottom: 3px; }
        .japanese-text { font-size: 18px; color: #666; }
        .definition-text { font-size: 14px; color: #444; margin: 5px 0; line-height: 1.3; text-align: center; }
        .placeholder-text { color: #aaa; font-size: 16px; }

        .progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
        }
        .progress-container.active { display: block; }
        .progress-text { color: white; font-size: 18px; margin-bottom: 15px; }
        .progress-bar { width: 200px; height: 10px; background: rgba(255,255,255,0.3); border-radius: 5px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #4facfe, #00f2fe); border-radius: 5px; transition: width 0.3s ease; width: 0%; }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 80%;
        }
        .error-message h2 { color: #f44336; margin-bottom: 15px; }
        .error-message p { color: #666; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="camera-container" id="cameraContainer">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <canvas id="detectCanvas"></canvas>

            <button class="settings-btn" id="settingsBtn">⚙️</button>

            <div class="card-mask not-tracking" id="cardMask"></div>

            <div class="focus-overlay not-tracking" id="focusOverlay">
                <div class="corner corner-tl"></div>
                <div class="corner corner-tr"></div>
                <div class="corner corner-bl"></div>
                <div class="corner corner-br"></div>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-text" id="progressText">よみとりちゅう...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="error-message" id="errorMessage" style="display: none;">
                <h2>カメラが つかえません</h2>
                <p>カメラの きょかを おねがいします</p>
            </div>
        </div>

        <div class="controls">
            <div class="result-area" id="resultArea">
                <span class="placeholder-text">カメラで じしょを うつしてね</span>
            </div>

            <div class="button-row">
                <button class="btn btn-capture" id="captureBtn">
                    <span>よみとる</span>
                </button>
            </div>

            <div class="button-row">
                <button class="btn btn-speak" id="speakBtn" disabled>
                    <span>えいごで よむ</span>
                </button>
                <button class="btn btn-translate" id="translateBtn" disabled>
                    <span>にほんご</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h2>⚙️ せってい</h2>
            <div class="api-status inactive" id="apiStatus">Cloud Vision: みせってい</div>
            <label for="apiKeyInput">Google Cloud Vision API Key</label>
            <input type="password" id="apiKeyInput" placeholder="APIキーを にゅうりょく">
            <p style="font-size: 12px; color: #888; margin-bottom: 15px;">
                APIキーがない場合は Tesseract.js を使用します
            </p>
            <div class="modal-buttons">
                <button class="cancel-btn" id="cancelBtn">キャンセル</button>
                <button class="save-btn" id="saveBtn">ほぞん</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let currentHeadword = '';
        let currentText = '';
        let japaneseText = '';
        let japaneseExplanation = '';
        let stream = null;
        let tesseractWorker = null;
        let detectionRunning = false;
        let currentCardRect = null;
        let apiKey = localStorage.getItem('gcv_api_key') || '';

        // Dictionary - Japanese word translations
        const childrensDictionary = {
            'ant': 'あり', 'bear': 'くま', 'bee': 'はち', 'bird': 'とり',
            'butterfly': 'ちょうちょ', 'cat': 'ねこ', 'cow': 'うし', 'dog': 'いぬ',
            'duck': 'あひる', 'elephant': 'ぞう', 'fish': 'さかな', 'frog': 'かえる',
            'horse': 'うま', 'lion': 'らいおん', 'monkey': 'さる', 'mouse': 'ねずみ',
            'pig': 'ぶた', 'rabbit': 'うさぎ', 'sheep': 'ひつじ', 'snake': 'へび',
            'spider': 'くも', 'tiger': 'とら', 'turtle': 'かめ', 'whale': 'くじら',
            'zebra': 'しまうま', 'apple': 'りんご', 'banana': 'バナナ', 'bread': 'パン',
            'cake': 'ケーキ', 'candy': 'あめ', 'carrot': 'にんじん', 'cheese': 'チーズ',
            'chocolate': 'チョコレート', 'cookie': 'クッキー', 'egg': 'たまご',
            'grape': 'ぶどう', 'juice': 'ジュース', 'milk': 'ぎゅうにゅう',
            'orange': 'オレンジ', 'pizza': 'ピザ', 'rice': 'ごはん',
            'strawberry': 'いちご', 'tomato': 'トマト', 'water': 'みず',
            'arm': 'うで', 'ear': 'みみ', 'eye': 'め', 'face': 'かお',
            'finger': 'ゆび', 'foot': 'あし', 'hand': 'て', 'head': 'あたま',
            'mouth': 'くち', 'nose': 'はな', 'tooth': 'は',
            'black': 'くろ', 'blue': 'あお', 'brown': 'ちゃいろ', 'green': 'みどり',
            'pink': 'ピンク', 'purple': 'むらさき', 'red': 'あか', 'white': 'しろ',
            'yellow': 'きいろ', 'baby': 'あかちゃん', 'boy': 'おとこのこ',
            'girl': 'おんなのこ', 'family': 'かぞく', 'father': 'おとうさん',
            'mother': 'おかあさん', 'brother': 'おにいちゃん', 'sister': 'おねえちゃん',
            'ball': 'ボール', 'bed': 'ベッド', 'book': 'ほん', 'box': 'はこ',
            'car': 'くるま', 'chair': 'いす', 'clock': 'とけい', 'cup': 'コップ',
            'door': 'ドア', 'flower': 'はな', 'hat': 'ぼうし', 'house': 'おうち',
            'key': 'かぎ', 'pen': 'ペン', 'pencil': 'えんぴつ', 'phone': 'でんわ',
            'shoe': 'くつ', 'table': 'テーブル', 'toy': 'おもちゃ', 'tree': 'き',
            'umbrella': 'かさ', 'window': 'まど', 'add': 'たす', 'come': 'くる',
            'dance': 'おどる', 'drink': 'のむ', 'eat': 'たべる', 'go': 'いく',
            'help': 'たすける', 'jump': 'とぶ', 'listen': 'きく', 'look': 'みる',
            'play': 'あそぶ', 'read': 'よむ', 'run': 'はしる', 'sing': 'うたう',
            'sit': 'すわる', 'sleep': 'ねる', 'stand': 'たつ', 'stop': 'とまる',
            'swim': 'およぐ', 'talk': 'はなす', 'walk': 'あるく', 'write': 'かく',
            'afraid': 'こわい', 'angry': 'おこっている', 'bad': 'わるい',
            'beautiful': 'きれい', 'big': 'おおきい', 'cold': 'さむい',
            'good': 'いい', 'happy': 'うれしい', 'hot': 'あつい', 'hungry': 'おなかすいた',
            'little': 'ちいさい', 'long': 'ながい', 'new': 'あたらしい',
            'old': 'ふるい', 'sad': 'かなしい', 'short': 'みじかい', 'small': 'ちいさい',
            'tall': 'たかい', 'tired': 'つかれた', 'home': 'おうち', 'park': 'こうえん',
            'school': 'がっこう', 'shop': 'おみせ', 'zoo': 'どうぶつえん',
            'actor': 'はいゆう', 'doctor': 'おいしゃさん', 'friend': 'ともだち',
            'teacher': 'せんせい', 'address': 'じゅうしょ', 'afternoon': 'ごご',
            'morning': 'あさ', 'night': 'よる', 'sun': 'たいよう', 'moon': 'つき',
            'star': 'ほし', 'rain': 'あめ', 'snow': 'ゆき', 'class': 'クラス',
            'classroom': 'きょうしつ', 'child': 'こども', 'children': 'こどもたち',
            'city': 'まち', 'chin': 'あご', 'cherry': 'さくらんぼ', 'chef': 'シェフ',
            'chicken': 'にわとり', 'unhappy': 'かなしい', 'under': 'した',
            'understand': 'わかる', 'upright': 'まっすぐ', 'upset': 'かなしい',
            'bright': 'あかるい', 'more': 'もっと', 'month': 'つき'
        };


        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const detectCanvas = document.getElementById('detectCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const detectCtx = detectCanvas.getContext('2d', { willReadFrequently: true });
        const cameraContainer = document.getElementById('cameraContainer');
        const cardMask = document.getElementById('cardMask');
        const focusOverlay = document.getElementById('focusOverlay');
        const progressContainer = document.getElementById('progressContainer');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const errorMessage = document.getElementById('errorMessage');
        const resultArea = document.getElementById('resultArea');
        const captureBtn = document.getElementById('captureBtn');
        const speakBtn = document.getElementById('speakBtn');
        const translateBtn = document.getElementById('translateBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const modalOverlay = document.getElementById('modalOverlay');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const apiStatus = document.getElementById('apiStatus');
        const saveBtn = document.getElementById('saveBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        // Settings modal
        function updateApiStatus() {
            if (apiKey) {
                apiStatus.textContent = 'Cloud Vision: せっていずみ ✓';
                apiStatus.className = 'api-status active';
            } else {
                apiStatus.textContent = 'Cloud Vision: みせってい (Tesseract使用)';
                apiStatus.className = 'api-status inactive';
            }
        }

        settingsBtn.addEventListener('click', () => {
            apiKeyInput.value = apiKey;
            updateApiStatus();
            modalOverlay.classList.add('active');
        });

        cancelBtn.addEventListener('click', () => {
            modalOverlay.classList.remove('active');
        });

        saveBtn.addEventListener('click', () => {
            apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                localStorage.setItem('gcv_api_key', apiKey);
            } else {
                localStorage.removeItem('gcv_api_key');
            }
            updateApiStatus();
            modalOverlay.classList.remove('active');
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.classList.remove('active');
            }
        });

        // Initialize Tesseract (fallback)
        async function initTesseract() {
            if (apiKey) {
                // Skip Tesseract init if using Cloud Vision
                return;
            }

            progressContainer.classList.add('active');
            progressText.textContent = 'じゅんびちゅう...';
            progressFill.style.width = '10%';

            try {
                tesseractWorker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            progressFill.style.width = Math.round(m.progress * 100) + '%';
                        }
                    }
                });
                progressFill.style.width = '100%';
                progressText.textContent = 'じゅんびかんりょう！';
                await new Promise(r => setTimeout(r, 500));
            } catch (err) {
                console.error('Tesseract init error:', err);
                progressText.textContent = 'エラーが おきました';
            } finally {
                progressContainer.classList.remove('active');
                progressFill.style.width = '0%';
            }
        }

        // Initialize camera
        async function initCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;
                await video.play();

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    detectCanvas.width = video.videoWidth / 4;
                    detectCanvas.height = video.videoHeight / 4;
                    startCardDetection();
                });
            } catch (err) {
                console.error('Camera error:', err);
                errorMessage.style.display = 'block';
            }
        }

        // Detect card-like rectangles
        function detectCards() {
            if (!video.videoWidth) return [];

            const w = detectCanvas.width;
            const h = detectCanvas.height;

            detectCtx.drawImage(video, 0, 0, w, h);
            const imageData = detectCtx.getImageData(0, 0, w, h);
            const data = imageData.data;

            const gray = new Uint8Array(w * h);
            const edges = new Uint8Array(w * h);

            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    const idx = y * w + x;
                    const gx = Math.abs(gray[idx + 1] - gray[idx - 1]);
                    const gy = Math.abs(gray[idx + w] - gray[idx - w]);
                    edges[idx] = Math.min(255, gx + gy);
                }
            }

            const cards = [];
            const minSize = Math.min(w, h) * 0.15;
            const maxSize = Math.min(w, h) * 0.8;
            const gridSize = 8;
            const edgeDensity = [];

            for (let gy = 0; gy < h; gy += gridSize) {
                for (let gx = 0; gx < w; gx += gridSize) {
                    let sum = 0, count = 0;
                    for (let dy = 0; dy < gridSize && gy + dy < h; dy++) {
                        for (let dx = 0; dx < gridSize && gx + dx < w; dx++) {
                            sum += edges[(gy + dy) * w + (gx + dx)];
                            count++;
                        }
                    }
                    edgeDensity.push({ x: gx, y: gy, density: sum / count });
                }
            }

            const threshold = 30;
            const highEdge = edgeDensity.filter(e => e.density > threshold);

            if (highEdge.length > 4) {
                const centerX = w / 2, centerY = h / 2;
                const nearCenter = highEdge.filter(e => {
                    const dx = e.x - centerX, dy = e.y - centerY;
                    return Math.sqrt(dx * dx + dy * dy) < Math.min(w, h) * 0.4;
                });

                if (nearCenter.length > 0) {
                    let minX = w, minY = h, maxX = 0, maxY = 0;
                    nearCenter.forEach(e => {
                        minX = Math.min(minX, e.x);
                        minY = Math.min(minY, e.y);
                        maxX = Math.max(maxX, e.x + gridSize);
                        maxY = Math.max(maxY, e.y + gridSize);
                    });

                    const size = Math.min(maxX - minX, maxY - minY);
                    if (size >= minSize && size <= maxSize) {
                        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
                        cards.push({
                            x: (cx - size / 2) * 4,
                            y: (cy - size / 2) * 4,
                            width: size * 4,
                            height: size * 4
                        });
                    }
                }
            }

            if (cards.length === 0) {
                const size = Math.min(video.videoWidth, video.videoHeight) * 0.4;
                cards.push({
                    x: (video.videoWidth - size) / 2,
                    y: (video.videoHeight - size) / 2,
                    width: size,
                    height: size
                });
            }

            return cards;
        }

        function updateOverlay(rect) {
            const videoRect = video.getBoundingClientRect();
            const scaleX = videoRect.width / video.videoWidth;
            const scaleY = videoRect.height / video.videoHeight;
            const offsetX = (videoRect.width - video.videoWidth * scaleX) / 2;
            const offsetY = (videoRect.height - video.videoHeight * scaleY) / 2;

            const left = (rect.x * scaleX + offsetX) + 'px';
            const top = (rect.y * scaleY + offsetY) + 'px';
            const width = (rect.width * scaleX) + 'px';
            const height = (rect.height * scaleY) + 'px';

            focusOverlay.style.left = left;
            focusOverlay.style.top = top;
            focusOverlay.style.width = width;
            focusOverlay.style.height = height;

            cardMask.style.left = left;
            cardMask.style.top = top;
            cardMask.style.width = width;
            cardMask.style.height = height;

            currentCardRect = rect;
        }

        function startCardDetection() {
            detectionRunning = true;

            function detect() {
                if (!detectionRunning) return;

                const cards = detectCards();
                if (cards.length > 0) {
                    const centerX = video.videoWidth / 2, centerY = video.videoHeight / 2;
                    let closest = cards[0], minDist = Infinity;

                    cards.forEach(card => {
                        const cx = card.x + card.width / 2, cy = card.y + card.height / 2;
                        const dist = Math.sqrt((cx - centerX) ** 2 + (cy - centerY) ** 2);
                        if (dist < minDist) { minDist = dist; closest = card; }
                    });

                    updateOverlay(closest);
                    focusOverlay.classList.remove('not-tracking');
                    focusOverlay.classList.add('tracking');
                    cardMask.classList.remove('not-tracking');
                    cardMask.classList.add('tracking');
                } else {
                    focusOverlay.classList.remove('tracking');
                    focusOverlay.classList.add('not-tracking');
                    cardMask.classList.remove('tracking');
                    cardMask.classList.add('not-tracking');
                }

                requestAnimationFrame(detect);
            }

            detect();
        }

        // Capture card (no preprocessing for Cloud Vision)
        function captureCard(forCloudVision = false) {
            if (!currentCardRect) {
                const size = Math.min(video.videoWidth, video.videoHeight) * 0.4;
                currentCardRect = {
                    x: (video.videoWidth - size) / 2,
                    y: (video.videoHeight - size) / 2,
                    width: size,
                    height: size
                };
            }

            const { x, y, width, height } = currentCardRect;
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(video, x, y, width, height, 0, 0, width, height);

            if (!forCloudVision) {
                // Preprocessing for Tesseract
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    const contrast = 1.4;
                    const factor = (259 * (contrast * 100 + 255)) / (255 * (259 - contrast * 100));
                    const newGray = Math.max(0, Math.min(255, factor * (gray - 128) + 128));
                    const threshold = 145;
                    const finalValue = newGray > threshold ? 255 : 0;
                    data[i] = data[i + 1] = data[i + 2] = finalValue;
                }

                ctx.putImageData(imageData, 0, 0);
            }

            return canvas;
        }

        // Google Cloud Vision API OCR
        async function performCloudVisionOCR(canvasElement) {
            const base64 = canvasElement.toDataURL('image/jpeg', 0.9).split(',')[1];

            const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    requests: [{
                        image: { content: base64 },
                        features: [{ type: 'TEXT_DETECTION' }]
                    }]
                })
            });

            const data = await response.json();

            if (data.error) {
                throw new Error(data.error.message);
            }

            const textAnnotations = data.responses?.[0]?.textAnnotations;
            if (!textAnnotations || textAnnotations.length === 0) {
                return { fullText: '', headword: null };
            }

            // First annotation is full text
            const fullText = textAnnotations[0].description || '';

            // Find the topmost word (headword) using bounding box positions
            // Skip first annotation (full text), use individual words
            const words = textAnnotations.slice(1);
            let headword = null;
            let minY = Infinity;

            for (const word of words) {
                const text = word.description;
                // Only consider words with 2+ letters
                if (!/^[a-zA-Z]{2,}$/.test(text)) continue;

                const vertices = word.boundingPoly?.vertices;
                if (vertices && vertices.length > 0) {
                    const topY = Math.min(...vertices.map(v => v.y || 0));
                    if (topY < minY) {
                        minY = topY;
                        headword = text.toLowerCase();
                    }
                }
            }

            console.log('Cloud Vision - Full:', fullText);
            console.log('Cloud Vision - Headword:', headword);

            return { fullText, headword };
        }

        // Tesseract OCR (fallback)
        async function performTesseractOCR(canvasElement) {
            if (!tesseractWorker) {
                await initTesseract();
            }
            const result = await tesseractWorker.recognize(canvasElement);
            return result.data.text.trim();
        }

        // Main OCR function
        async function performOCR() {
            progressContainer.classList.add('active');
            progressText.textContent = 'よみとりちゅう...';
            progressFill.style.width = '30%';

            try {
                if (apiKey) {
                    // Use Cloud Vision
                    const canvasEl = captureCard(true);
                    progressFill.style.width = '50%';
                    const result = await performCloudVisionOCR(canvasEl);
                    progressFill.style.width = '100%';
                    return result; // { fullText, headword }
                } else {
                    // Use Tesseract
                    const canvasEl = captureCard(false);
                    progressFill.style.width = '50%';
                    const ocrText = await performTesseractOCR(canvasEl);
                    console.log('Tesseract OCR:', ocrText);
                    progressFill.style.width = '100%';
                    return extractTextFromTesseract(ocrText);
                }
            } finally {
                progressContainer.classList.remove('active');
                progressFill.style.width = '0%';
            }
        }

        // Extract headword and definition from Tesseract OCR text
        function extractTextFromTesseract(ocrText) {
            if (!ocrText) return { fullText: '', headword: null };

            // Split into lines
            const lines = ocrText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            if (lines.length === 0) return { fullText: '', headword: null };

            // First line typically contains the headword
            const firstLine = lines[0];

            // Extract headword (first word, possibly with parentheses like "child (children)")
            const headwordMatch = firstLine.match(/^([a-zA-Z]+)/);
            const headword = headwordMatch ? headwordMatch[1].toLowerCase() : null;

            // Full text is all lines joined
            const fullText = lines.join(' ')
                .replace(/\s+/g, ' ')
                .trim();

            return {
                headword: headword,
                fullText: fullText
            };
        }

        // Translation
        async function getTranslation(word) {
            if (!word) return '';
            const lower = word.toLowerCase();
            if (childrensDictionary[lower]) return childrensDictionary[lower];

            try {
                const res = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|ja`);
                const data = await res.json();
                if (data.responseStatus === 200) return data.responseData.translatedText;
            } catch (e) {
                console.error('Translation error:', e);
            }
            return '';
        }

        // Extract definition from OCR text (remove headword from beginning)
        function extractDefinition(headword, fullText) {
            if (!fullText || !headword) return '';

            // Remove the headword from the beginning of fullText
            let definition = fullText;
            const lowerFull = fullText.toLowerCase();
            const lowerHead = headword.toLowerCase();

            // Find and remove the headword
            const headIndex = lowerFull.indexOf(lowerHead);
            if (headIndex !== -1) {
                definition = fullText.substring(headIndex + headword.length).trim();
            }

            // Clean up: remove leading punctuation, parentheses content at start
            definition = definition.replace(/^[\s,.:;]+/, '').trim();

            return definition;
        }

        // Translate definition to Japanese
        async function translateDefinition(definition) {
            if (!definition) return '';

            try {
                const res = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(definition)}&langpair=en|ja`);
                const data = await res.json();
                if (data.responseStatus === 200) {
                    return data.responseData.translatedText;
                }
            } catch (e) {
                console.error('Definition translation error:', e);
            }
            return '';
        }

        // Speech
        let englishVoice = null, japaneseVoice = null;

        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            englishVoice = voices.find(v => v.lang.startsWith('en'));
            japaneseVoice = voices.find(v => v.lang.startsWith('ja'));
        }
        loadVoices();
        speechSynthesis.onvoiceschanged = loadVoices;

        function speakEnglish(text) {
            if (!text) return;
            speechSynthesis.cancel();
            setTimeout(() => {
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'en-US';
                if (englishVoice) u.voice = englishVoice;
                u.rate = 0.4; // Slower for children
                speechSynthesis.speak(u);
            }, 100);
        }

        function speakJapanese(text) {
            if (!text) return;
            speechSynthesis.cancel();
            setTimeout(() => {
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'ja-JP';
                if (japaneseVoice) u.voice = japaneseVoice;
                u.rate = 0.8;
                speechSynthesis.speak(u);
            }, 100);
        }

        // UI
        function updateResult(headword, fullText, japanese, explanation) {
            currentHeadword = headword;
            currentText = fullText;
            japaneseText = japanese;
            japaneseExplanation = explanation || '';

            const esc = s => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            resultArea.innerHTML = `
                <div class="english-text">${esc(headword)}</div>
                <div class="definition-text">${esc(fullText)}</div>
                <div class="japanese-text">${esc(japanese)}</div>
            `;

            speakBtn.disabled = false;
            translateBtn.disabled = false;
        }

        function showError(msg) {
            resultArea.innerHTML = `<span class="placeholder-text">${msg}</span>`;
            speakBtn.disabled = true;
            translateBtn.disabled = true;
        }

        // Events
        captureBtn.addEventListener('click', async () => {
            captureBtn.disabled = true;

            try {
                const result = await performOCR();

                if (!result || !result.headword) {
                    showError('もじが みつかりませんでした');
                    return;
                }

                progressText.textContent = 'ほんやくちゅう...';
                progressContainer.classList.add('active');

                // Get Japanese word translation
                const japanese = await getTranslation(result.headword);

                // Extract definition and translate to Japanese
                const definition = extractDefinition(result.headword, result.fullText);
                const japaneseDefinition = await translateDefinition(definition);

                progressContainer.classList.remove('active');

                updateResult(result.headword, result.fullText, japanese, japaneseDefinition);

                // Auto-speak the headword after capture
                speakEnglish(result.headword);
            } catch (err) {
                console.error('Error:', err);
                showError('エラーが おきました');
                progressContainer.classList.remove('active');
            } finally {
                captureBtn.disabled = false;
            }
        });

        // Speak headword in English (slowly for children)
        speakBtn.addEventListener('click', () => speakEnglish(currentHeadword));

        // Speak Japanese explanation (or translation if no explanation)
        translateBtn.addEventListener('click', () => {
            const textToSpeak = japaneseExplanation || japaneseText;
            speakJapanese(textToSpeak);
        });

        // Init
        async function init() {
            updateApiStatus();
            await initCamera();
            if (!apiKey) {
                await initTesseract();
            }
        }

        init();
    </script>
</body>
</html>
