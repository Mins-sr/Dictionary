<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>えいご じしょ</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
            background: #f0f8ff;
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            max-width: 100%;
        }

        .camera-container {
            position: relative;
            flex: 1;
            background: #000;
            overflow: hidden;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas, #detectCanvas {
            display: none;
        }

        /* Square focus overlay with corner brackets */
        .focus-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            transition: all 0.15s ease-out;
        }

        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border-color: #4caf50;
            border-style: solid;
            border-width: 0;
        }

        .corner-tl {
            top: 0;
            left: 0;
            border-top-width: 5px;
            border-left-width: 5px;
        }

        .corner-tr {
            top: 0;
            right: 0;
            border-top-width: 5px;
            border-right-width: 5px;
        }

        .corner-bl {
            bottom: 0;
            left: 0;
            border-bottom-width: 5px;
            border-left-width: 5px;
        }

        .corner-br {
            bottom: 0;
            right: 0;
            border-bottom-width: 5px;
            border-right-width: 5px;
        }

        .focus-overlay.tracking .corner {
            border-color: #4caf50;
        }

        .focus-overlay.not-tracking .corner {
            border-color: #ffeb3b;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 15px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom, 0));
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            flex-shrink: 0;
        }

        .button-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .btn {
            flex: 1;
            max-width: 180px;
            padding: 15px 12px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-capture {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
        }

        .btn-speak {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-translate {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(67, 233, 123, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .result-area {
            background: white;
            border-radius: 12px;
            padding: 10px 12px;
            margin-bottom: 4px;
            min-height: 60px;
            max-height: 120px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .english-text {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 3px;
        }

        .japanese-text {
            font-size: 18px;
            color: #666;
        }

        .definition-text {
            font-size: 14px;
            color: #444;
            margin: 5px 0;
            line-height: 1.3;
            text-align: center;
        }

        .placeholder-text {
            color: #aaa;
            font-size: 16px;
        }

        .progress-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-text {
            color: white;
            font-size: 18px;
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 200px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border-radius: 5px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 80%;
        }

        .error-message h2 {
            color: #f44336;
            margin-bottom: 15px;
        }

        .error-message p {
            color: #666;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="camera-container" id="cameraContainer">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <canvas id="detectCanvas"></canvas>

            <div class="focus-overlay not-tracking" id="focusOverlay">
                <div class="corner corner-tl"></div>
                <div class="corner corner-tr"></div>
                <div class="corner corner-bl"></div>
                <div class="corner corner-br"></div>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-text" id="progressText">よみとりちゅう...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="error-message" id="errorMessage" style="display: none;">
                <h2>カメラが つかえません</h2>
                <p>カメラの きょかを おねがいします</p>
            </div>
        </div>

        <div class="controls">
            <div class="result-area" id="resultArea">
                <span class="placeholder-text">カメラで じしょを うつしてね</span>
            </div>

            <div class="button-row">
                <button class="btn btn-capture" id="captureBtn">
                    <span>よみとる</span>
                </button>
            </div>

            <div class="button-row">
                <button class="btn btn-speak" id="speakBtn" disabled>
                    <span>えいごで よむ</span>
                </button>
                <button class="btn btn-translate" id="translateBtn" disabled>
                    <span>にほんご</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // State
        let currentText = '';
        let japaneseText = '';
        let stream = null;
        let tesseractWorker = null;
        let detectionRunning = false;
        let currentCardRect = null;

        // Dictionary
        const childrensDictionary = {
            'ant': 'あり', 'bear': 'くま', 'bee': 'はち', 'bird': 'とり',
            'butterfly': 'ちょうちょ', 'cat': 'ねこ', 'cow': 'うし', 'dog': 'いぬ',
            'duck': 'あひる', 'elephant': 'ぞう', 'fish': 'さかな', 'frog': 'かえる',
            'horse': 'うま', 'lion': 'らいおん', 'monkey': 'さる', 'mouse': 'ねずみ',
            'pig': 'ぶた', 'rabbit': 'うさぎ', 'sheep': 'ひつじ', 'snake': 'へび',
            'spider': 'くも', 'tiger': 'とら', 'turtle': 'かめ', 'whale': 'くじら',
            'zebra': 'しまうま', 'apple': 'りんご', 'banana': 'バナナ', 'bread': 'パン',
            'cake': 'ケーキ', 'candy': 'あめ', 'carrot': 'にんじん', 'cheese': 'チーズ',
            'chocolate': 'チョコレート', 'cookie': 'クッキー', 'egg': 'たまご',
            'grape': 'ぶどう', 'juice': 'ジュース', 'milk': 'ぎゅうにゅう',
            'orange': 'オレンジ', 'pizza': 'ピザ', 'rice': 'ごはん',
            'strawberry': 'いちご', 'tomato': 'トマト', 'water': 'みず',
            'arm': 'うで', 'ear': 'みみ', 'eye': 'め', 'face': 'かお',
            'finger': 'ゆび', 'foot': 'あし', 'hand': 'て', 'head': 'あたま',
            'mouth': 'くち', 'nose': 'はな', 'tooth': 'は',
            'black': 'くろ', 'blue': 'あお', 'brown': 'ちゃいろ', 'green': 'みどり',
            'pink': 'ピンク', 'purple': 'むらさき', 'red': 'あか', 'white': 'しろ',
            'yellow': 'きいろ', 'baby': 'あかちゃん', 'boy': 'おとこのこ',
            'girl': 'おんなのこ', 'family': 'かぞく', 'father': 'おとうさん',
            'mother': 'おかあさん', 'brother': 'おにいちゃん', 'sister': 'おねえちゃん',
            'ball': 'ボール', 'bed': 'ベッド', 'book': 'ほん', 'box': 'はこ',
            'car': 'くるま', 'chair': 'いす', 'clock': 'とけい', 'cup': 'コップ',
            'door': 'ドア', 'flower': 'はな', 'hat': 'ぼうし', 'house': 'おうち',
            'key': 'かぎ', 'pen': 'ペン', 'pencil': 'えんぴつ', 'phone': 'でんわ',
            'shoe': 'くつ', 'table': 'テーブル', 'toy': 'おもちゃ', 'tree': 'き',
            'umbrella': 'かさ', 'window': 'まど', 'add': 'たす', 'come': 'くる',
            'dance': 'おどる', 'drink': 'のむ', 'eat': 'たべる', 'go': 'いく',
            'help': 'たすける', 'jump': 'とぶ', 'listen': 'きく', 'look': 'みる',
            'play': 'あそぶ', 'read': 'よむ', 'run': 'はしる', 'sing': 'うたう',
            'sit': 'すわる', 'sleep': 'ねる', 'stand': 'たつ', 'stop': 'とまる',
            'swim': 'およぐ', 'talk': 'はなす', 'walk': 'あるく', 'write': 'かく',
            'afraid': 'こわい', 'angry': 'おこっている', 'bad': 'わるい',
            'beautiful': 'きれい', 'big': 'おおきい', 'cold': 'さむい',
            'good': 'いい', 'happy': 'うれしい', 'hot': 'あつい', 'hungry': 'おなかすいた',
            'little': 'ちいさい', 'long': 'ながい', 'new': 'あたらしい',
            'old': 'ふるい', 'sad': 'かなしい', 'short': 'みじかい', 'small': 'ちいさい',
            'tall': 'たかい', 'tired': 'つかれた', 'home': 'おうち', 'park': 'こうえん',
            'school': 'がっこう', 'shop': 'おみせ', 'zoo': 'どうぶつえん',
            'actor': 'はいゆう', 'doctor': 'おいしゃさん', 'friend': 'ともだち',
            'teacher': 'せんせい', 'address': 'じゅうしょ', 'afternoon': 'ごご',
            'morning': 'あさ', 'night': 'よる', 'sun': 'たいよう', 'moon': 'つき',
            'star': 'ほし', 'rain': 'あめ', 'snow': 'ゆき', 'class': 'クラス',
            'classroom': 'きょうしつ', 'child': 'こども', 'children': 'こどもたち',
            'city': 'まち', 'chin': 'あご', 'cherry': 'さくらんぼ', 'chef': 'シェフ',
            'chicken': 'にわとり', 'unhappy': 'かなしい', 'under': 'した',
            'understand': 'わかる', 'upright': 'まっすぐ', 'upset': 'かなしい'
        };

        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const detectCanvas = document.getElementById('detectCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const detectCtx = detectCanvas.getContext('2d', { willReadFrequently: true });
        const cameraContainer = document.getElementById('cameraContainer');
        const focusOverlay = document.getElementById('focusOverlay');
        const progressContainer = document.getElementById('progressContainer');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const errorMessage = document.getElementById('errorMessage');
        const resultArea = document.getElementById('resultArea');
        const captureBtn = document.getElementById('captureBtn');
        const speakBtn = document.getElementById('speakBtn');
        const translateBtn = document.getElementById('translateBtn');

        // Initialize Tesseract
        async function initTesseract() {
            progressContainer.classList.add('active');
            progressText.textContent = 'じゅんびちゅう...';
            progressFill.style.width = '10%';

            try {
                tesseractWorker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            progressFill.style.width = Math.round(m.progress * 100) + '%';
                        }
                    }
                });
                progressFill.style.width = '100%';
                progressText.textContent = 'じゅんびかんりょう！';
                await new Promise(r => setTimeout(r, 500));
            } catch (err) {
                console.error('Tesseract init error:', err);
                progressText.textContent = 'エラーが おきました';
            } finally {
                progressContainer.classList.remove('active');
                progressFill.style.width = '0%';
            }
        }

        // Initialize camera
        async function initCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;
                await video.play();

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    detectCanvas.width = video.videoWidth / 4;
                    detectCanvas.height = video.videoHeight / 4;
                    startCardDetection();
                });
            } catch (err) {
                console.error('Camera error:', err);
                errorMessage.style.display = 'block';
            }
        }

        // Detect card-like rectangles in the video
        function detectCards() {
            if (!video.videoWidth) return [];

            const w = detectCanvas.width;
            const h = detectCanvas.height;

            // Draw scaled down video frame
            detectCtx.drawImage(video, 0, 0, w, h);
            const imageData = detectCtx.getImageData(0, 0, w, h);
            const data = imageData.data;

            // Convert to grayscale and detect edges
            const gray = new Uint8Array(w * h);
            const edges = new Uint8Array(w * h);

            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }

            // Simple edge detection (Sobel-like)
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    const idx = y * w + x;
                    const gx = Math.abs(gray[idx + 1] - gray[idx - 1]);
                    const gy = Math.abs(gray[idx + w] - gray[idx - w]);
                    edges[idx] = Math.min(255, gx + gy);
                }
            }

            // Find rectangular regions by scanning for edge patterns
            const cards = [];
            const minSize = Math.min(w, h) * 0.15;
            const maxSize = Math.min(w, h) * 0.8;

            // Scan for potential card boundaries using edge density
            const gridSize = 8;
            const edgeDensity = [];

            for (let gy = 0; gy < h; gy += gridSize) {
                for (let gx = 0; gx < w; gx += gridSize) {
                    let sum = 0;
                    let count = 0;
                    for (let dy = 0; dy < gridSize && gy + dy < h; dy++) {
                        for (let dx = 0; dx < gridSize && gx + dx < w; dx++) {
                            sum += edges[(gy + dy) * w + (gx + dx)];
                            count++;
                        }
                    }
                    edgeDensity.push({
                        x: gx,
                        y: gy,
                        density: sum / count
                    });
                }
            }

            // Find regions with high edge density (card borders)
            const threshold = 30;
            const highEdge = edgeDensity.filter(e => e.density > threshold);

            if (highEdge.length > 4) {
                // Find bounding box of high edge regions near center
                const centerX = w / 2;
                const centerY = h / 2;

                // Group nearby edge regions
                const nearCenter = highEdge.filter(e => {
                    const dx = e.x - centerX;
                    const dy = e.y - centerY;
                    return Math.sqrt(dx * dx + dy * dy) < Math.min(w, h) * 0.4;
                });

                if (nearCenter.length > 0) {
                    let minX = w, minY = h, maxX = 0, maxY = 0;
                    nearCenter.forEach(e => {
                        minX = Math.min(minX, e.x);
                        minY = Math.min(minY, e.y);
                        maxX = Math.max(maxX, e.x + gridSize);
                        maxY = Math.max(maxY, e.y + gridSize);
                    });

                    const cardW = maxX - minX;
                    const cardH = maxY - minY;

                    // Make it square (use smaller dimension)
                    const size = Math.min(cardW, cardH);
                    if (size >= minSize && size <= maxSize) {
                        const cx = (minX + maxX) / 2;
                        const cy = (minY + maxY) / 2;

                        cards.push({
                            x: (cx - size / 2) * 4,
                            y: (cy - size / 2) * 4,
                            width: size * 4,
                            height: size * 4
                        });
                    }
                }
            }

            // If no card detected, use center square
            if (cards.length === 0) {
                const size = Math.min(video.videoWidth, video.videoHeight) * 0.4;
                cards.push({
                    x: (video.videoWidth - size) / 2,
                    y: (video.videoHeight - size) / 2,
                    width: size,
                    height: size
                });
            }

            return cards;
        }

        // Update overlay position
        function updateOverlay(rect) {
            const containerRect = cameraContainer.getBoundingClientRect();
            const videoRect = video.getBoundingClientRect();

            // Calculate scale between video display and actual video
            const scaleX = videoRect.width / video.videoWidth;
            const scaleY = videoRect.height / video.videoHeight;

            // Calculate offset (for object-fit: cover)
            const offsetX = (videoRect.width - video.videoWidth * scaleX) / 2;
            const offsetY = (videoRect.height - video.videoHeight * scaleY) / 2;

            const displayX = rect.x * scaleX + offsetX;
            const displayY = rect.y * scaleY + offsetY;
            const displayW = rect.width * scaleX;
            const displayH = rect.height * scaleY;

            focusOverlay.style.left = displayX + 'px';
            focusOverlay.style.top = displayY + 'px';
            focusOverlay.style.width = displayW + 'px';
            focusOverlay.style.height = displayH + 'px';

            currentCardRect = rect;
        }

        // Start card detection loop
        function startCardDetection() {
            detectionRunning = true;

            function detect() {
                if (!detectionRunning) return;

                const cards = detectCards();
                if (cards.length > 0) {
                    // Find card closest to center
                    const centerX = video.videoWidth / 2;
                    const centerY = video.videoHeight / 2;

                    let closest = cards[0];
                    let minDist = Infinity;

                    cards.forEach(card => {
                        const cx = card.x + card.width / 2;
                        const cy = card.y + card.height / 2;
                        const dist = Math.sqrt((cx - centerX) ** 2 + (cy - centerY) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = card;
                        }
                    });

                    updateOverlay(closest);
                    focusOverlay.classList.remove('not-tracking');
                    focusOverlay.classList.add('tracking');
                } else {
                    focusOverlay.classList.remove('tracking');
                    focusOverlay.classList.add('not-tracking');
                }

                requestAnimationFrame(detect);
            }

            detect();
        }

        // Capture the detected card region
        function captureCard() {
            if (!currentCardRect) {
                // Fallback to center
                const size = Math.min(video.videoWidth, video.videoHeight) * 0.4;
                currentCardRect = {
                    x: (video.videoWidth - size) / 2,
                    y: (video.videoHeight - size) / 2,
                    width: size,
                    height: size
                };
            }

            const { x, y, width, height } = currentCardRect;

            canvas.width = width;
            canvas.height = height;

            ctx.drawImage(video, x, y, width, height, 0, 0, width, height);

            // Preprocessing
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                const contrast = 1.4;
                const factor = (259 * (contrast * 100 + 255)) / (255 * (259 - contrast * 100));
                const newGray = Math.max(0, Math.min(255, factor * (gray - 128) + 128));
                const threshold = 145;
                const finalValue = newGray > threshold ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = finalValue;
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // OCR
        async function performOCR(canvasElement) {
            if (!tesseractWorker) throw new Error('Tesseract not initialized');

            progressContainer.classList.add('active');
            progressText.textContent = 'よみとりちゅう...';
            progressFill.style.width = '0%';

            try {
                const result = await tesseractWorker.recognize(canvasElement);
                console.log('OCR:', result.data.text);
                return result.data.text.trim();
            } finally {
                progressContainer.classList.remove('active');
                progressFill.style.width = '0%';
            }
        }

        // Extract text
        function extractText(ocrText) {
            if (!ocrText) return null;

            const cleaned = ocrText
                .replace(/[^\w\s.,!?'"-]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();

            if (!cleaned) return null;

            const words = cleaned.split(/\s+/);
            const headword = words.find(w => /^[a-zA-Z]{2,}$/.test(w));

            return {
                headword: headword ? headword.toLowerCase() : words[0]?.toLowerCase(),
                fullText: cleaned
            };
        }

        // Translation
        async function getTranslation(word) {
            if (!word) return '';
            const lower = word.toLowerCase();
            if (childrensDictionary[lower]) return childrensDictionary[lower];

            try {
                const res = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|ja`);
                const data = await res.json();
                if (data.responseStatus === 200) return data.responseData.translatedText;
            } catch (e) {
                console.error('Translation error:', e);
            }
            return '';
        }

        // Speech
        let englishVoice = null, japaneseVoice = null;

        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            englishVoice = voices.find(v => v.lang.startsWith('en'));
            japaneseVoice = voices.find(v => v.lang.startsWith('ja'));
        }
        loadVoices();
        speechSynthesis.onvoiceschanged = loadVoices;

        function speakEnglish(text) {
            if (!text) return;
            speechSynthesis.cancel();
            setTimeout(() => {
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'en-US';
                if (englishVoice) u.voice = englishVoice;
                u.rate = 0.6;
                speechSynthesis.speak(u);
            }, 100);
        }

        function speakJapanese(text) {
            if (!text) return;
            speechSynthesis.cancel();
            setTimeout(() => {
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'ja-JP';
                if (japaneseVoice) u.voice = japaneseVoice;
                u.rate = 0.8;
                speechSynthesis.speak(u);
            }, 100);
        }

        // UI
        function updateResult(headword, fullText, japanese) {
            currentText = fullText;
            japaneseText = japanese;

            const esc = s => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            resultArea.innerHTML = `
                <div class="english-text">${esc(headword)}</div>
                <div class="definition-text">${esc(fullText)}</div>
                <div class="japanese-text">${esc(japanese)}</div>
            `;

            speakBtn.disabled = false;
            translateBtn.disabled = false;
        }

        function showError(msg) {
            resultArea.innerHTML = `<span class="placeholder-text">${msg}</span>`;
            speakBtn.disabled = true;
            translateBtn.disabled = true;
        }

        // Events
        captureBtn.addEventListener('click', async () => {
            captureBtn.disabled = true;

            try {
                const canvasEl = captureCard();
                const ocrText = await performOCR(canvasEl);
                const extracted = extractText(ocrText);

                if (!extracted) {
                    showError('もじが みつかりませんでした');
                    return;
                }

                progressText.textContent = 'ほんやくちゅう...';
                progressContainer.classList.add('active');

                const japanese = await getTranslation(extracted.headword);
                progressContainer.classList.remove('active');

                updateResult(extracted.headword || '', extracted.fullText, japanese);
            } catch (err) {
                console.error('Error:', err);
                showError('エラーが おきました');
                progressContainer.classList.remove('active');
            } finally {
                captureBtn.disabled = false;
            }
        });

        speakBtn.addEventListener('click', () => speakEnglish(currentText));
        translateBtn.addEventListener('click', () => speakJapanese(japaneseText));

        // Init
        async function init() {
            await initCamera();
            await initTesseract();
        }

        init();
    </script>
</body>
</html>
